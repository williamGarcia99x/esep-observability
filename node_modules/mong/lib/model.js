'use strict'

module.exports = Document

var mapStream = require('map-stream')

var ObjectId = require('mongodb').ObjectID

var PROTO = '__proto__'

module.exports = Document

function Document (o) {
  o = o || {}

  // Cast _id to ObjectId
  if (typeof o._id === 'string') {
    this._id = new ObjectId(o._id)
  } else if (typeof o._id === 'object') {
    this._id = o._id
  }

  this._id = this._id || new ObjectId()

  for (var i in o) {
    if (i !== '_id' && Object.hasOwnProperty.call(o, i)) {
      this[i] = o[i]
    }
  }
}

/**
 * Get Collection
 * @param {Constructor} constructor model constructor
 * @return {MongoDB.Collection}
 */
function get (constructor) {
  return constructor.getCollection()
}

function convert (proto) {
  return function (result) {
    if (!result) return result
    if (Array.isArray[result]) {
      result.forEach(function (doc) {
        doc[PROTO] = proto
      })
      return result
    }
    result[PROTO] = proto
    return result
  }
}

// ===== Static Methods =====

Document.findById = function (_id) {
  if (typeof _id === 'string') _id = new ObjectId(_id)
  return this.findOne.apply(this, arguments)
}

function mapped (name) {
  return function () {
    var args = arguments

    return get(this)
    .then(function (c) {
      return c[name].apply(c, args)
    })
    .then(convert(this.prototype))
  }
}

function mappedArray (name) {
  return function () {
    var args = arguments
    var proto = this.prototype
    return get(this)
    .then(function (c) {
      return c[name].apply(c, args).toArray()
    })
    .then(function (array) {
      array.forEach(function (doc) {
        doc[PROTO] = proto
      })
      return array
    })
  }
}

function mappedRawResult (name) {
  return function () {
    var args = arguments
    return get(this)
    .then(function (c) {
      return c[name].apply(c, args)
    })
    .then(function (k) {
      return k.result
    })
  }
}

function mappedStream (name) {
  return function () {
    var prototype = this.prototype
    var output = mapStream(function (data, callback) {
      data[PROTO] = prototype
      callback(null, data)
    })

    var args = arguments

    get(this)
    .then(function (c) {
      var input = c[name].apply(c, args)
      input.pipe(output)
    })
    .then(null, function (err) {
      output.emit('error', err)
    })
    return output
  }
}

Document.findOne = mapped('findOne')
Document.findAndModify = mapped('findAndModify')
Document.find = mappedArray('find')

Document._collection = function () {
  return get(this)
}

;['update', 'remove', 'aggregate', 'ensureIndex']
.forEach(function (name) {
  Document[name] = mappedRawResult(name)
})

Document.stream = mappedStream('find')
Document.aggregateStream = mappedStream('aggregate')

// ===== Instance Methods =====

Document.prototype.save = function () {
  var doc = this
  return get(this.constructor)
  .then(function (c) {
    return c.save(doc)
  })
  .then(function () {
    return doc
  })
}

Document.prototype.update = function (changes, options) {
  var args = [{_id: this._id}].concat(Array.prototype.slice.call(arguments))
  return this.constructor.update.apply(this.constructor, args)
}

Document.prototype.remove = function (options) {
  var args = [{_id: this._id}].concat(Array.prototype.slice.call(arguments))
  return this.constructor.remove.apply(this.constructor, args)
}

/**
 * Update command parametrized by ObjectId(this._id).
 * @param  {Object}   query    additional update conditions
 * @param  {Object}   updates  changes to make. E.g. {$set: {x: 2}}
 * @param  {Object}   options  options
 * @param  {Function} callback
 */
Document.prototype.updateIf = function (query, changes) {
  query = Object.create(query)
  query._id = this._id
  return this.constructor.update.apply(this.constructor, arguments)
}
